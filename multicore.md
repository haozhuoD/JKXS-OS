## QEMU启动多核
```shell
# 启动双核
make run CPUS=2
```

## 如何用gdb调试多核

https://stackoverflow.com/questions/42800801/how-to-use-gdb-to-debug-qemu-with-smp-symmetric-multiple-processors

```
i th 查看线程信息
thr x 切换到x号线程
```

## 初步尝试

将`UPSafeCell`全部替换为`Mutex`，并为每个processor设置自己的全局变量.观察到现象：cpu0正常启动，轮到cpu1运行任务时会报错：no tasks available in run_tasks。
之后内核疯狂`panic`，输出字母顺序是乱的。

## console加锁

结果是cpu0直接卡死（卡在console那里），cpu1由于cpu0未初始化完成也卡死。
用`Mutex<ConsoleInner>`代替`Arc<Mutex<ConsoleInner>>`，问题解决。我也不知道为啥（现在知道了，原因是堆内存未初始化）

## 三核（四核）出现跑飞

现象:程序跑飞，程序运行到奇怪位置。随后内核进入死锁状态，

**注意: `b trap_from_kernel` 是一个非常好的调试方法!!**
> 程序跑飞而导致Instruction Page Fault（已解决）

> 这个死锁的直接结果就是在内核因为ra异常，程序运行在了没有设定的地址范围内。在排查之后，发现间接原因是task_cx被修改了。然后，使用gdb抓取出现Instruction Page Fault的时刻，也就是进入trap_from_kernel的时候，发现两个核使用的都是一个内核栈，而这并不符合内核的设定。正常来说，内核运行的栈严格和当前处理器核运行进程的pid绑定，或者转入idle_cx也就是初始栈，但这仍然不可能出现两个核处在相同的栈。结合task_cx的问题，我们推测是栈的切换过程之中出现了空隙，使得这种异常现象得以发生。

> 最后，我们发现，是切换的时候锁的控制出现了空隙。在内核进行进程切换的时候，先将当前进程放入空闲进程队列，再从队列中寻找下一个进程，这使得该核在使用该进程栈的同时，却有可能将该进程放手给了另一个核。

> 因此我们必须强制使得每个核必须手握至少一个进程的锁，也就是先找到下一个可以切换的进程，再将当前进程放入队列中。但是显然，这会造成死锁，所以我们采用了非常巧妙的方法，那就是：如果当前没有下一个进程，就不进行进程切换，返回原来的进程。这样的让出争抢锁的方式避免了死锁的发生可能。

> 具体操作我们还遇到了一些小问题：
> - cpu运行第一个程序的时候核自身没有程序，这个时候不能“返回原来的进程”，要特殊判断，持续争抢下一个进程。
> - 注意手动释放锁
>- loop块的作用域等等细节实现问题

## 多核退出竞争问题