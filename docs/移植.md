# *Porting Manual*

## 移植标准riscv64 linux的rootfs

### 问题1 无法找到lib目录下的链接库ld-linux-riscv64-lp64d.so.1

问题可能是fat32文件系统不支持多个 `.` 分割的扩展名，修复之。

发现又跑不通，调试发现find_long_name的参数name最后竟然带了一个 `\0` ，追根溯源可以发现这个 `\0`在用户态就被传进来了，因此需要在load_dl时加上一句：`s=s.strip_suffix("\0").unwrap_or(&s).to_string();`

用来去除末尾的\0。结果可以跑通

### 问题2 试图读取/lib64/lp64d/tls/libm.so.6时报错

```shell
[syscall tid=2] : ***sys_open_at(dirfd: -100, path: "/lib64/lp64d/tls/libm.so.6", flags: CLOEXEC, mode: 0x0) = ?
[ ERROR ] "src/lang_items.rs" @ 9 : Panicked at /home/user/oskernel2022/fat32_fs/src/layout.rs:314 called `Result::unwrap()` on an `Err` value: Utf8Error { valid_up_to: 0, error_len: Some(1) }
```

发现文件系统的layout.rs有一处细节错误，会导致无法正确跨簇读取目录项。进一步测试发现类似的几个地方都存在相同错误，一起修复。（这么严重的问题到现在才发现？）

### 问题3 试图读取/lib64/lp64d/libm.so.6时报错

```sh
[syscall tid=3] : sys_open_at(dirfd: -100, path: "/lib64/lp64d/libm.so.6", flags: CLOEXEC, mode: 0x0) = -2
```

返回值不应该是-2，因为文件是存在的。检查发现我们错误地把libm.so.6当作短文件名处理了，实际上它应该是长文件名。事实上，对于一个文件名来说，无论其长短，只要其含有两个 `.` 就自动视为长文件名。

### 问题4 运行bin/sh之后，cd bin，然后ls，报错ls: not found

注意到ls和./ls是不同的，ls必须去 `PATH` 里面找，但是./ls则是执行当前目录下找。如果想在任意目录下跑ls，则必须将/bin加入环境变量中。

### 问题5 运行bin/sh之后，cd usr/bin，然后ls，直接卡死

发现是translated_buffer_mut()出了问题，居然将虚拟地址翻译成了一个物理地址0。检查发现这个虚拟地址实际上已经被分配(by sbrk)，但是由于lazy机制尚未插入页表，导致翻译出错。解决方法是每次翻译时都check一下lazy。
