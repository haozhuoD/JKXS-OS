# *Porting Manual*

## 移植标准riscv64 linux的rootfs

### 问题1 无法找到lib目录下的链接库ld-linux-riscv64-lp64d.so.1

问题可能是fat32文件系统不支持多个 `.` 分割的扩展名，修复之。

发现又跑不通，调试发现find_long_name的参数name最后竟然带了一个 `\0` ，追根溯源可以发现这个 `\0`在用户态就被传进来了，因此需要在load_dl时加上一句：`s=s.strip_suffix("\0").unwrap_or(&s).to_string();`

用来去除末尾的\0。结果可以跑通

### 问题2 试图读取/lib64/lp64d/tls/libm.so.6时报错

```shell
[syscall tid=2] : ***sys_open_at(dirfd: -100, path: "/lib64/lp64d/tls/libm.so.6", flags: CLOEXEC, mode: 0x0) = ?
[ ERROR ] "src/lang_items.rs" @ 9 : Panicked at /home/user/oskernel2022/fat32_fs/src/layout.rs:314 called `Result::unwrap()` on an `Err` value: Utf8Error { valid_up_to: 0, error_len: Some(1) }
```

发现文件系统的layout.rs有一处细节错误，会导致无法正确跨簇读取目录项。进一步测试发现类似的几个地方都存在相同错误，一起修复。（这么严重的问题到现在才发现？）

### 问题3 试图读取/lib64/lp64d/libm.so.6时报错

```sh
[syscall tid=3] : sys_open_at(dirfd: -100, path: "/lib64/lp64d/libm.so.6", flags: CLOEXEC, mode: 0x0) = -2
```

返回值不应该是-2，因为文件是存在的。检查发现我们错误地把libm.so.6当作短文件名处理了，实际上它应该是长文件名。事实上，对于一个文件名来说，无论其长短，只要其含有两个 `.` 就自动视为长文件名。
