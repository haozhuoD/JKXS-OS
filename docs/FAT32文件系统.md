# FAT32文件系统

文件系统的实现采用了五层的分层结构，从下到上分别为磁盘块设备接口层、块缓存层、磁盘布局层、文件系统管理层、虚拟文件系统层。

## 磁盘块设备接口层

磁盘块设备接口层提供了 `BlockDevice` trait，该trait要求实现两个方法 `read_block`和 `write_block`以分别用于对块设备的读写，这相当于提供了块设备的抽象接口，无论是哪种块设备，只要实现了这个trait，都可以接入文件系统以供使用。

## 块缓存层

块缓存层用于在内存中缓存磁盘块的数据，其中实现了块缓存 `BlockCache`和块缓存管理器 `BlockCacheManager`。

块缓存 `BlockCache`向外提供了 `read`和 `modify`接口，用于对块缓存的读写。当创建一个 `BlockCache`时，会通过磁盘块设备接口层所提供的接口，将一个磁盘块读取到缓冲区中。

我们设定缓存的大小为5KB，即可以同时驻留10个磁盘块。考虑到FAT32文件系统对文件进行读写的特殊性，我们设置了两个缓存，分别为信息缓存和数据缓存。其中信息缓存用于缓存FAT表、引导扇区、FSInfo扇区、目录等用于信息检索的块，而数据缓存则用于缓存文件内容。为此，我们也提供了两个全局块缓存管理器 `INFO_BLOCK_CACHE_MANAGER`和 `DATA_BLOCK_CACHE_MANAGER`。

## 磁盘布局层

### DBR(DOS Boot Record)

DOS引导记录占据一个扇区，且通常位于0号扇区(逻辑0扇区)，下文中的BPB和EBR二者共同组成DBR的512个字节。DBR用于解释文件系统，一般仅在进入文件系统时读入。我们为BPB实现了成员字段与磁盘数据一一对应的结构体，而EBR由于冗余数据过多，仅实现到FSInfo(文件系统信息扇区)为止。在进入文件系统读入DBR扇区后，就可以将块缓存的引用转换为BPB和EBR结构体的应用，从而通过对应字段来获取文件系统的相关信息。

#### BPB(BIOS Parameter Block)

| 字节偏移(十进制) | 字节偏移(十六进制) | 字节数 | 意义                             |
| ---------------- | ------------------ | ------ | -------------------------------- |
| 0                | 0x00               | 3      | 跳转指令                         |
| 3                | 0x03               | 8      | 文件系统标志和版本号             |
| 11               | 0x0B               | 2      | 每个扇区的字节数                 |
| 13               | 0x0D               | 1      | 每个簇的扇区数                   |
| 14               | 0x0E               | 2      | 保留区的扇区数(包含引导记录扇区) |
| 16               | 0x10               | 1      | FAT表个数(通常为2)               |
| 17               | 0x11               | 2      | 0                                |
| 19               | 0x13               | 2      | 0                                |
| 21               | 0x15               | 1      | 存储介质                         |
| 22               | 0x16               | 2      | 0                                |
| 24               | 0x18               | 2      | 每磁道扇区数                     |
| 26               | 0x1A               | 2      | 磁头数                           |
| 28               | 0x1C               | 4      | EBR分区之前所隐藏的扇区数        |
| 32               | 0x20               | 4      | 文件系统总扇区数                 |

#### EBR(Extended Boot Record)

EBR紧跟在BPB的后面，二者共占一个扇区

| 字节偏移(十进制) | 字节偏移(十六进制) | 字节数 | 意义                    |
| ---------------- | ------------------ | ------ | ----------------------- |
| 36               | 0x24               | 4      | 每个FAT表占用扇区数     |
| 40               | 0x28               | 2      | 标志                    |
| 42               | 0x2A               | 2      | FAT版本号               |
| 44               | 0x2C               | 4      | 根目录所在簇号，通常为2 |
| 48               | 0x30               | 2      | FSInfo扇区号            |
| 50               | 0x32               | 2      | 备份引导扇区的扇区号    |
| 52               | 0x34               | 12     | 保留                    |
| 64               | 0x40               | 1      | 驱动号                  |
| 65               | 0x41               | 1      | 保留                    |
| 66               | 0x42               | 1      | 0x29                    |
| 67               | 0x43               | 4      | 卷序列号，忽略          |
| 71               | 0x47               | 11     | 卷标                    |
| 82               | 0x52               | 8      | "FAT32"                 |
| 90               | 0x5A               | 420    | 引导代码                |
| 510              | 0x1FE              | 2      | 0xAA55                  |

### FSInfo Structure

FSInfo信息扇区一般位于文件系统的1号扇区，用于记录文件系统中空闲簇的数量和最近一次分配的簇号，帮助空闲簇的检索。FSInfo扇区中的有效字段非常少，但是需要频繁地读写。考虑到这个因素，我们仍然为其实现了完整的结构体 `FSInfoInner`，作为结构体 `FSInfo`的成员之一。其常驻内存，且不通过块缓存来进行读写，对FSInfo扇区进行读写只需要修改 `FSInfoInner`结构体字段的值即可。当然，我们也为FSInfo实现了同步机制，我们维护了FSInfo扇区所在的物理扇区号 `fsinfo_sector`，当 `FSInfo`的生命周期结束或者需要同步到磁盘时，就会将 `FSInfoInner`即FSInfo扇区的内容写入到磁盘中的对应位置。

| 字节偏移(十进制) | 字节偏移(十六进制) | 字节数 | 意义               |
| ---------------- | ------------------ | ------ | ------------------ |
| 0                | 0x0                | 4      | 0x41615252         |
| 4                | 0x4                | 480    | 保留，0            |
| 484              | 0x1E4              | 4      | 0x61417272         |
| 488              | 0x1E8              | 4      | 文件系统的空簇数   |
| 492              | 0x1EC              | 4      | 最近一次分配的簇号 |
| 496              | 0x1F0              | 12     | 保留               |
| 508              | 0x1FC              | 4      | 0xAA550000         |

### File Allocation Table(文件分配表FAT)

FAT32文件系统中分配磁盘空间按簇来分配，即文件在占用磁盘空间时的基本单位是簇。即使是一个只有一个字节的小文件，操作系统也会给它分配一个簇来存储。而对于大文件则可能需要多个簇来存储，这多个簇在磁盘中不一定是连续存放的。因此需要FAT表来描述簇的分配状态以及表明文件或目录的下一个簇的簇号。

FAT32中每个簇的簇地址为32bits，其中只使用低28位来寻址磁盘上的簇，保留最高的4位。FAT表中的所有字节位置以4字节为单位进行划分，并对所有划分后的位置由0进行地址编号。0号地址与1号地址被系统保留并存储特殊标志内容。从2号地址开始，每个地址对应于数据区的簇号，FAT表中的地址编号与数据区中的簇号相同。

当文件系统格式化时，分配给FAT表的区域会被清空，由于簇号起始于2号，FAT表的0号表项与1号表项不与任何簇对应，因此需要在FAT表的0号表项和1号表项写入对应的特定值，其中0号表项值总为0xFFFFFFF8，1号表项值总为0xFFFFFFFF。最后在2号FAT表项写入一个结束标志表示根目录。

在FAT表中获取簇链中当前簇cluster的下一个簇的簇号的方法为：

```rust
// first_fat_sector为FAT表的第一个扇区
// FAT_ENTRY_PER_SEC为每个扇区的FAT表项个数
let fat_sector = first_fat_sector + cluster / FAT_ENTRY_PER_SEC;
let fat_offset = 4 * (cluster % FAT_ENTRY_PER_SEC);

// 读取磁盘中逻辑扇区号为fat_sector的扇区读到块缓存中，并读取该扇区中偏移为fat_offset的4个字节得到next_cluster

return next_cluster & 0x0FFFFFFF
```

如果 `next_cluster` 大于等于0x0FFFFFF8，则表示该簇链中不再有簇了，整个文件已经被读取完。如果 `next_cluster` 等于0x0FFFFFF7，则表示这个簇为坏簇。如果 `next_cluster` 为0，说明对应簇未被分配使用。

基于上述方法，我们为FAT表实现了以下主要接口：

| 接口名称          | 描述                                                |
| ----------------- | --------------------------------------------------- |
| next_free_cluster | 查询某个簇开始的下一个空闲簇号                      |
| get_next_cluster  | 查询某个簇的下一个簇的簇号                          |
| set_next_cluster  | 设置某个簇的下一个簇的簇号                          |
| get_cluster_at    | 获取某个簇所在簇链的，从该簇开始计数的第i个簇的簇号 |
| get_final_cluster | 获取某个簇所在簇链的最后一个簇的簇号                |
| get_all_clusters  | 获取某个簇所在簇链的，从该簇开始的所有簇号          |
| cluster_count     | 获取某个簇所在簇链的，从该簇开始计数的簇的个数      |

上述接口均需要通过信息缓存对块设备进行读写，因此我们对FAT表的内存结构仅保存了FAT1、FAT2的起始扇区号和FAT表所允许的最大簇数。

### 目录

FAT文件系统中有两种类型的目录，分别是Standard 8.3目录项（出现在所有FAT文件系统上）和长文件名目录项（可选地出现以允许更长的文件名）

#### Standard 8.3(短文件名)

每个文件或子目录都一定会被分配一个短文件名目录项，短文件名目录项包含了文件的相关信息，包括文件名、拓展名、属性等，其格式如下：

| 字节偏移 | 字节数 | 含义                                                                                                          |
| -------- | ------ | ------------------------------------------------------------------------------------------------------------- |
| 0        | 11     | 文件名，前8个字符是名称(不足8个则用0x20填充)，后3个字符是扩展名(如果是子目录则用0x20填充)                     |
| 11       | 1      | 文件属性，包括READ_ONLY=0x01 HIDDEN=0x02 SYSTEM=0x04 VOLUME_ID=0x08 DIRECTORY=0x10 ARCHIVE=0x20 LFN=READ_ONLY |
| 12       | 1      | 默认为0，表示短文件名全大写表示（包括扩展名）                                                                 |
| 13       | 1      | 以十分之一秒为单位的文件创建时间                                                                              |
| 14       | 2      | 文件创建时间，其中小时占5bits，分钟占6bits，秒占5bits，秒数需要乘2                                            |
| 16       | 2      | 文件创建日期，其中年份占7bits（相对于1980年），月份占4bits，日期占5bits                                       |
| 18       | 2      | 文件最近访问日期                                                                                              |
| 20       | 2      | 文件起始簇号的高16位                                                                                          |
| 22       | 2      | 文件最近修改时间                                                                                              |
| 24       | 2      | 文件最近修改日期                                                                                              |
| 26       | 2      | 文件起始簇号的低16位                                                                                          |
| 28       | 4      | 以字节为单位的文件大小（如果是子目录则全置为0）                                                               |

需要注意的是，对于一个短文件名目录项的第一个字符，如果该目录项正在使用中则0x0位置的值为文件名或子目录名的第一个字符；如果该目录项未被使用则0x0位置的值为0x00；如果该目录项曾经被使用过但是现在已经被删除则0x0位置的值为0xE5。

对于短文件名目录项，我们实现了完整的结构体 `ShortDirEntry`与其磁盘数据一一对应。除了对其字段进行读写和判断外，我们还对短文件名目录项实现了以下的接口：

| 接口名称 | 描述                                     |
| -------- | ---------------------------------------- |
| get_pos  | 获取文件偏移量所在的簇、扇区和扇区内偏移 |
| read_at  | 以偏移量读文件                           |
| write_at | 以偏移量写文件                           |
| checksum | 计算短文件名的校验和                     |

事实上，以偏移量读写文件涉及到FAT表的读写、块缓存层的调用等等。通过上述接口的实现，上层模块在进行相关操作时，就不必关心其内部的复杂实现，只需要传入所需的参数即可。

#### Long File Names

长文件名目录项的格式如下：

| 字节偏移 | 字节数 | 含义                                                                 |
| -------- | ------ | -------------------------------------------------------------------- |
| 0        | 1      | 长文件名目录项的序列号                                               |
| 1        | 10     | 长文件名的1~5个字符（Unicode编码，每个字符两个字节）                 |
| 11       | 1      | 0x0F                                                                 |
| 12       | 1      | 0                                                                    |
| 13       | 1      | 短文件名的校验和(一个文件的不同长文件名的目录项的短文件名校验和相同) |
| 14       | 12     | 长文件名的6~11个字符                                                 |
| 26       | 2      | 0                                                                    |
| 28       | 4      | 长文件名的12~13个字符                                                |

长文件名目录项的注意点：

- 长文件名目录项总是有个紧随其后的Standard 8.3目录项。
- 系统将长文件名以13个字符为单位进行切割，每一组占据一个目录项。所以一个文件可能需要多个长文件名目录项，这时长文件名的各个目录项按倒序排列在目录表中，其第一部分距离短文件名目录项是最近的。
- 长文件名目录项的第一个字节为序列号。一个文件的第一个目录项序列号为1，然后依次递增。如果是该文件的最后一个长文件名目录项，则将该目录项的序号与0x40进行或运算的结果写入该位置。如果该长文件名目录项对应的文件或子目录被删除，则将该字节设置成删除标志0xE5。
- 长文件名如果结束了但还有未使用的字节，则会在在文件名后先填充两个的0x00，然后开始使用0xFF填充。

当创建一个长文件名文件时，其短文件名的命名原则为：

- 取长文件名的前6个字符加上”~1”形成短文件名，扩展名不变。
- 如果已存在这个文件名，则符号”~”后的数字递增，直到5。
- 如果文件名中"~"后面的数字达到5，则短文件名只使用长文件名的前两个字母。通过数学操纵长文件名的剩余字母生成短文件名的后四个字母，然后加后缀"~1"直到最后(如果有必要，可以是其他数字以避免重复的文件名)。

对于长文件名目录项，我们也实现了完整的结构体 `LongDirEntry`与其磁盘数据一一对应。

#### "."目录项和".."目录项

一个子目录的起始簇中的前两个目录项为"."目录项和".."目录项，其中"."目录项中记录的起始簇号也就是该子目录目前所处的位置。

## 文件系统管理层

我们在文件系统管理层实现了一个文件系统管理器 `FAT32Manager`，它用于统筹并联系起下层模块，并基于它们完成文件系统的打开、簇的分配与去分配等操作。

为此，`FAT32Manager`的结构体定义如下：

| 成员                | 描述                |
| ------------------- | ------------------- |
| bytes_per_sector    | 每个扇区的字节数    |
| bytes_per_cluster   | 每个簇的字节数      |
| sectors_per_cluster | 每个簇的扇区数      |
| root_sector         | 根目录所在扇区号    |
| block_device        | 块设备的引用        |
| fsinfo              | FSInfo结构体的引用  |
| fat                 | FAT表内存结构的引用 |
| root_dirent         | 虚拟根目录项        |

其中，我们知道FAT32文件系统中文件或目录的相关信息都存储在其短文件名目录项中，然后通过短文件名目录项 `ShortDirEntry`提供的相关接口就可以实现对文件或目录的读写等操作。然而，在FAT32文件系统中根目录并没有对应的目录项，因此我们创建了一个虚拟的根目录项，保存在 `FAT32Manager`的 `root_dirent`字段中，通过其来对根目录进行相关操作。

我们为FAT32Manager实现了以下主要接口：

| 接口名称        | 描述                      |
| --------------- | ------------------------- |
| open            | 打开文件系统              |
| clear_cluster   | 清除指定簇中的所有扇区    |
| alloc_cluster   | 在FAT表上分配指定数量个簇 |
| dealloc_cluster | 在FAT表上去分配指定的簇   |
| long_name_split | 拆分长文件名              |

其中 `open`即打开文件系统的流程如下：

1. 读入MBR所在扇区(物理0扇区)，读取其中0x1C6开始的4个字节的内容，即相对扇区数。设置块缓存的起始扇区偏移为该相对扇区数。此后通过块缓存层对磁盘进行访问仅需通过逻辑扇区号即可。(需要注意的是，读入MBR所在扇区时也是通过块缓存层完成，只不过块缓存层初始的起始扇区偏移为0)。
2. 读入逻辑0扇区，读取其中的BPB和EBR获取文件系统的相关信息。
3. 通过EBR中的FSInfo扇区号，读取FSInfo，校验签名并构造其内存结构。
4. 通过BPB的保留区的扇区数、EBR的FAT表占用扇区数等信息，构造FAT表的内存结构。
5. 构造虚拟根目录项。
6. 构造文件系统管理器并返回。

## 虚拟文件系统层

虚拟文件系统层实现了FAT32文件系统的虚拟文件对象 `VFile`。为了方便对其访问，我们记录了其短文件名目录项所在的扇区 `short_sector `、扇区偏移 `short_offset `以及其所有长文件名目录项的位置 `long_pos_vec `。同时因为对文件的操作需要底层文件系统和块设备的支持，所以我们也保存了文件系统和块设备的引用 `fs `和 `block_device `。为方便内核使用，我们也保存了文件名 `name `和属性 `attribute`。

我们为 `VFile`实现的主要接口如下：

| 接口名称        | 描述                                                                             |
| --------------- | -------------------------------------------------------------------------------- |
| create          | 在当前目录下创建目录项                                                           |
| find_vfile_name | 通过名称查找当前目录下的目录项                                                   |
| find_vfile_path | 通过相对路径查找目录项                                                           |
| read_at         | 对短文件名目录项的read_at的封装，以偏移量读取文件                                |
| write_at        | 对短文件名目录项的write_at的封装，以偏移量写文件                                 |
| ls              | 获取当前目录下的所有文件名及其属性                                               |
| dirent_info     | 获取当前目录下指定目录项的信息(包括名称、短文件名目录项偏移、起始簇号、属性)     |
| stat            | 获取当前目录下指定目录项的信息(包括大小、访问时间、修改时间、创建时间、起始簇号) |
| clear           | 清除文件内容                                                                     |
| remove          | 删除文件                                                                         |

# FAT32文件系统在用户态下的简单测试

通过Rust标准库中的 `std::file::File`可以访问Linux上的一个文件，在为其加锁后并为其实现 `BlockDevice` trait后，就相当于用Linux上的一个文件模拟一个块设备。使用 `File::create`在Linux上创建一个固定大小的文件 `fat32.img`，并对其进行FAT32格式化得到文件系统镜像，然后就可以利用这个镜像进行测试了。

我们进行了如下测试：

| 测试                 | 测试方法                                                                                                                       |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| 文件系统启动测试     | 使用文件系统打开FAT32镜像，测试是否能够正确读取文件系统基本信息、校验签名是否有效                                              |
| 文件创建测试         | 创建短文件名文件、长文件名文件、短文件名同名的长文件名文件                                                                     |
| 目录创建测试         | 创建目录与多级目录                                                                                                             |
| ls测试               | 在根目录和其子目录下调用ls方法                                                                                                 |
| 文件查找测试         | 通过文件名查找当前目录下的文件或目录。通过相对路径查找多级目录下的文件或目录，测试是否能够查找到                               |
| 文件读写测试         | 进行了单簇简单读写测试和多簇规定大小读写测试，通过写入再读出来判断内容是否一致                                                 |
| 文件删除测试         | 进行文件的删除，测试删除后能否ls或查找到已删除文件                                                                             |
| 文件系统写入磁盘测试 | 使用文件系统再次打开FAT32镜像，检查上一次写入磁盘的值是否正确。或者通过Linux下的mount命令将FAT32镜像挂载在目录下，检查相关的值 |

上述测试均通过。

# 相关操作

## 读取引导扇区

读取BPB：

```c
typedef struct fat_BS
{
	unsigned char 		bootjmp[3];
	unsigned char 		oem_name[8];
	unsigned short 	    bytes_per_sector;
	unsigned char		sectors_per_cluster;
	unsigned short		reserved_sector_count;
	unsigned char		table_count;
	unsigned short		root_entry_count;
	unsigned short		total_sectors_16;
	unsigned char		media_type;
	unsigned short		table_size_16;
	unsigned short		sectors_per_track;
	unsigned short		head_side_count;
	unsigned int 		hidden_sector_count;
	unsigned int 		total_sectors_32;

}__attribute__((packed)) fat_BS_t;
```

读取EBR：

```c
typedef struct fat_extBS_32
{
	//extended fat32 stuff
	unsigned int		table_size_32;
	unsigned short		extended_flags;
	unsigned short		fat_version;
	unsigned int		root_cluster;
	unsigned short		fat_info;
	unsigned short		backup_BS_sector;
	unsigned char 		reserved_0[12];
	unsigned char		drive_number;
	unsigned char 		reserved_1;
	unsigned char		boot_signature;
	unsigned int 		volume_id;
	unsigned char		volume_label[11];
	unsigned char		fat_type_label[8];
 
}__attribute__((packed)) fat_extBS_32_t;
```

有了上述的信息后，则有

总扇区数：
`total_sectors = fat_boot->total_sectors_32；`

每个FAT表占用扇区数：`fat_size = fat_boot_ext_32->table_size_32;`

第一个数据扇区(即根目录的第一个扇区号)：`first_data_sector = fat_boot->reserved_sector_count + (fat_boot->table_count * fat_size);`

FAT表中的第一个扇区:
`first_fat_sector = fat_boot->reserved_sector_count;`

数据扇区的总数：
`data_sectors = fat_boot->total_sectors - fat_boot->reserved_sector_count - fat_boot->table_count * fat_size;`

簇的总数（向下取整）:
`total_clusters = data_sectors / fat_boot->sectors_per_cluster;`

## 读取目录

读取目录的第一步就是找到并读取根目录。在FAT32中，根目录出现在给定簇的数据区中：
`root_cluster_32 = fat_boot_ext_32->root_cluster;`

对于给定的簇号cluster，其第一个扇区的位置为：`first_sector_of_cluster = ((cluster - 2) * fat_boot->sectors_per_cluster) + first_data_sector;`

### ls

对于簇中的每个32字节的条目，有：

1. 如果条目的第一个字节等于0，则此目录中没有文件/目录。即FirstByte==0，结束； FirstByte!=0，转到2。
2. 如果条目的第一个字节等于0xE5，说明这个条目不再使用。即FirstByte==0xE5，转到8; FirstByte!=0xE5，转到3。
3. 检查该条目是否是长文件名目录项，如果该条目的第11个字节等于0x0F，则是长文件名目录项，否则不是。即11thByte==0x0F，转到4； 11thByte!=0x0F，转到5。
4. 将长文件名的部分读到临时缓冲区中，转到8
5. 解析短文件名目录项中的数据，转到6
6. 在临时缓冲区中是否有长文件名，如果有则转到7，否则转到8
7. 临时缓冲区的长文件名就是刚刚解析的短文件名目录项的文件名，清除临时缓冲区，转到8
8. 递增指针和计数器读取下一个条目

重复上述操作直至簇中所有的条目都被读出

# 参考资料

https://wiki.osdev.org/FAT

https://blog.csdn.net/li_wen01/article/details/79929730

https://blog.csdn.net/u010650845/article/details/60780979
